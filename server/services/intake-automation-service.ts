import OpenAI from 'openai';
import Anthropic from '@anthropic-ai/sdk';
import { AvailityClearinghouseService } from './availity-clearinghouse';
import { EligibilityVerificationService, InsuranceInfo } from './eligibility-verification-service';

export interface ReferralDocument {
  type: 'pdf' | 'fax' | 'email';
  content: string; // base64 or text content
  fileName?: string;
  source: string;
}

export interface ExtractedReferralData {
  patientName: string;
  dateOfBirth: string;
  diagnosis: string;
  physicianName: string;
  referralDate: string;
  insuranceInfo: any;
  contactInfo: any;
  medicalHistory?: string;
  medications?: string[];
  allergies?: string[];
  confidence: number; // 0-100
  missingFields: string[];
  validationIssues: string[];
  aiReasoning: string;
}

export interface EligibilityResult {
  isEligible: boolean;
  payerType: string;
  planName: string;
  effectiveDate: string;
  expirationDate?: string;
  copayAmount?: number;
  deductible?: number;
  authorizationRequired: boolean;
  recommendations: string[];
  aiSummary: string;
}

export interface HomeboundAssessmentResult {
  isHomebound: boolean;
  criteria: {
    mobilityLimitation: boolean;
    assistanceRequired: boolean;
    taxingEffort: boolean;
    medicalReason: boolean;
  };
  supportingEvidence: string[];
  missingDocumentation: string[];
  complianceRisk: 'low' | 'medium' | 'high';
  aiRationale: string;
}

export interface SmartSchedulingResult {
  recommendedStaff: {
    staffId: number;
    name: string;
    role: string;
    confidence: number;
    reasoning: string;
  }[];
  proposedDateTime: Date;
  socComplianceStatus: 'compliant' | 'at_risk' | 'violation';
  workloadBalance: string;
  travelOptimization: string;
}

export interface ConsentValidationResult {
  isComplete: boolean;
  signedForms: string[];
  missingForms: string[];
  signatureValidity: boolean;
  hipaaCompliant: boolean;
  auditTrail: any[];
  recommendations: string[];
}

export class IntakeAutomationService {
  private openai: OpenAI;
  private anthropic: Anthropic;
  private availityService: AvailityClearinghouseService;
  private eligibilityService: EligibilityVerificationService;

  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });
    
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    this.availityService = new AvailityClearinghouseService();
    this.eligibilityService = new EligibilityVerificationService();
  }

  async autonomousFieldPopulator(documentContent: string, documentType: string): Promise<{
    extractedData: ExtractedReferralData;
    autoGeneratedContent: any;
    validationResults: any;
    riskAssessment: any;
  }> {
    try {
      console.log('Starting AI field population...');
      
      const prompt = `
You are an advanced healthcare intake AI specialist with expertise in medical documentation processing.

Analyze this ${documentType} document and extract all relevant patient information with high accuracy:

Document Content:
${documentContent}

Extract and validate the following information:

1. Patient Demographics
2. Medical Information (diagnoses, medications, allergies)
3. Referral Details (physician, date, services requested)
4. Insurance Information
5. Clinical History

Provide comprehensive analysis in JSON format:
{
  "patientName": "extracted patient name",
  "dateOfBirth": "YYYY-MM-DD format",
  "diagnosis": "primary diagnosis with ICD codes if available",
  "physicianName": "referring physician name",
  "referralDate": "YYYY-MM-DD format",
  "insuranceInfo": {"type": "insurance type", "policy": "policy number"},
  "contactInfo": {"phone": "phone number", "address": "full address"},
  "medicalHistory": "relevant medical history",
  "medications": ["current medications"],
  "allergies": ["known allergies"],
  "confidence": 95,
  "missingFields": ["list of missing required fields"],
  "validationIssues": ["any data inconsistencies found"],
  "aiReasoning": "detailed explanation of extraction process and confidence"
}

Focus on accuracy and healthcare compliance standards.
`;

      // Updated to use OpenAI GPT-4.1 model per user request
      const response = await this.openai.chat.completions.create({
        model: "gpt-4.1",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.3,
        max_tokens: 4000
      });

      const aiResult = JSON.parse(response.choices[0].message.content || '{}');
      
      return {
        extractedData: {
          patientName: aiResult.patientName || '',
          dateOfBirth: aiResult.dateOfBirth || '',
          diagnosis: aiResult.diagnosis || '',
          physicianName: aiResult.physicianName || '',
          referralDate: aiResult.referralDate || '',
          insuranceInfo: aiResult.insuranceInfo || {},
          contactInfo: aiResult.contactInfo || {},
          medicalHistory: aiResult.medicalHistory || '',
          medications: aiResult.medications || [],
          allergies: aiResult.allergies || [],
          confidence: aiResult.confidence || 0.95,
          missingFields: aiResult.missingFields || [],
          validationIssues: aiResult.validationIssues || [],
          aiReasoning: aiResult.aiReasoning || ''
        },
        autoGeneratedContent: {
          medicalSummary: aiResult.medicalSummary || '',
          complianceNotes: aiResult.complianceNotes || '',
          riskFactors: aiResult.riskFactors || []
        },
        validationResults: {
          completeness: aiResult.completeness || 85,
          accuracy: aiResult.accuracy || 90,
          flaggedIssues: aiResult.flaggedIssues || []
        },
        riskAssessment: {
          overallRisk: aiResult.overallRisk || 'low',
          clinicalRisks: aiResult.clinicalRisks || [],
          complianceRisks: aiResult.complianceRisks || []
        }
      };
    } catch (error) {
      console.error('Error in autonomous field population:', error);
      throw new Error('Failed to process document with AI');
    }
  }

  async processReferralDocument(document: ReferralDocument): Promise<ExtractedReferralData> {
    const prompt = `
You are a healthcare intake specialist AI. Extract and validate patient information from this referral document.

Document Type: ${document.type}
Source: ${document.source}
Content: ${document.content}

Extract the following information and provide validation:

1. Patient Demographics:
   - Full name
   - Date of birth
   - Address and contact information
   - Emergency contact

2. Medical Information:
   - Primary diagnosis (with ICD-10 if available)
   - Secondary diagnoses
   - Current medications
   - Known allergies
   - Medical history

3. Referral Details:
   - Referring physician name and contact
   - Referral date
   - Requested services
   - Insurance information

4. Validation Tasks:
   - Check for missing required fields
   - Validate date formats and consistency
   - Flag any data inconsistencies
   - Assess document completeness

Provide response in JSON format:
{
  "patientName": "string",
  "dateOfBirth": "YYYY-MM-DD",
  "diagnosis": "string",
  "physicianName": "string", 
  "referralDate": "YYYY-MM-DD",
  "insuranceInfo": {},
  "contactInfo": {},
  "medicalHistory": "string",
  "medications": ["string"],
  "allergies": ["string"],
  "confidence": 95,
  "missingFields": ["string"],
  "validationIssues": ["string"],
  "aiReasoning": "detailed explanation of extraction and validation"
}

Focus on accuracy and compliance with healthcare documentation standards.
`;

    try {
      // Updated to use OpenAI GPT-4.1 model per user request
      const response = await this.openai.chat.completions.create({
        model: "gpt-4.1",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.3
      });

      const result = JSON.parse(response.choices[0].message.content || '{}');
      
      return {
        patientName: result.patientName || '',
        dateOfBirth: result.dateOfBirth || '',
        diagnosis: result.diagnosis || '',
        physicianName: result.physicianName || '',
        referralDate: result.referralDate || '',
        insuranceInfo: result.insuranceInfo || {},
        contactInfo: result.contactInfo || {},
        medicalHistory: result.medicalHistory || '',
        medications: result.medications || [],
        allergies: result.allergies || [],
        confidence: result.confidence || 85,
        missingFields: result.missingFields || [],
        validationIssues: result.validationIssues || [],
        aiReasoning: result.aiReasoning || 'AI processing completed successfully'
      };
    } catch (error) {
      console.error('Error processing referral document:', error);
      throw new Error('Failed to process referral document');
    }
  }

  async executeFullIntakeProcess(referralDocument: ReferralDocument): Promise<{
    extractionResult: any;
    eligibilityResult: EligibilityResult;
    homeboundResult: HomeboundAssessmentResult;
    schedulingResult: SmartSchedulingResult;
    validationResult: ConsentValidationResult;
    summary: any;
    processingTime: number;
  }> {
    const startTime = Date.now();
    
    try {
      console.log('Starting full autonomous intake process...');

      // Step 1: Extract patient data using AI
      const extractionResult = await this.autonomousFieldPopulator(
        referralDocument.content, 
        referralDocument.type
      );

      // Step 2: Mock eligibility check (replace with real API integration)
      const eligibilityResult: EligibilityResult = {
        isEligible: true,
        payerType: 'Medicare',
        planName: 'Medicare Part A',
        effectiveDate: new Date().toISOString().split('T')[0],
        authorizationRequired: false,
        recommendations: ['Proceed with intake'],
        aiSummary: 'Patient eligible for home health services'
      };

      // Step 3: Mock homebound assessment
      const homeboundResult: HomeboundAssessmentResult = {
        isHomebound: true,
        criteria: {
          mobilityLimitation: true,
          assistanceRequired: true,
          taxingEffort: true,
          medicalReason: true
        },
        supportingEvidence: ['Post-surgical recovery', 'Limited mobility'],
        missingDocumentation: [],
        complianceRisk: 'low',
        aiRationale: 'Patient meets homebound criteria based on medical condition'
      };

      // Step 4: Mock scheduling
      const schedulingResult: SmartSchedulingResult = {
        recommendedStaff: [{
          staffId: 1,
          name: 'Nurse Jane Smith',
          role: 'RN',
          confidence: 95,
          reasoning: 'Best match for patient condition'
        }],
        proposedDateTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
        socComplianceStatus: 'compliant',
        workloadBalance: 'Optimal',
        travelOptimization: 'Efficient route planned'
      };

      // Step 5: Mock consent validation
      const validationResult: ConsentValidationResult = {
        isComplete: true,
        signedForms: ['Admission Agreement', 'HIPAA Authorization'],
        missingForms: [],
        signatureValidity: true,
        hipaaCompliant: true,
        auditTrail: [],
        recommendations: ['All consents obtained']
      };

      // Step 6: Generate AI summary
      const completionTime = Date.now() - startTime;
      
      const summaryPrompt = `
Generate a comprehensive summary for this completed autonomous intake process:

Patient: ${extractionResult.extractedData.patientName}
Diagnosis: ${extractionResult.extractedData.diagnosis}
Processing Time: ${completionTime}ms
Eligibility Status: eligible
Homebound Status: qualified
Appointment Scheduled: Yes

Provide a professional summary and actionable next steps in JSON format:
{
  "summary": "Comprehensive intake summary",
  "complianceStatus": "compliant",
  "actionItems": ["specific next steps"],
  "completenessScore": 95,
  "urgencyLevel": "medium"
}`;

      const summaryResponse = await this.openai.chat.completions.create({
        model: "gpt-4.1",
        messages: [{ role: "user", content: summaryPrompt }],
        response_format: { type: "json_object" },
        temperature: 0.3
      });

      const summary = JSON.parse(summaryResponse.choices[0].message.content || '{}');

      return {
        extractionResult,
        eligibilityResult,
        homeboundResult,
        schedulingResult,
        validationResult,
        summary,
        processingTime: completionTime
      };

    } catch (error) {
      console.error('Error in full intake process:', error);
      throw new Error('Autonomous intake process failed');
    }
  }

  /**
   * Enhanced Real-Time Eligibility Verification with Availity Clearinghouse Integration
   * Integrates with document analysis and pre-claim validation pipeline
   */
  async hyperIntelligentEligibilityProcessor(
    extractedData: ExtractedReferralData,
    documentContent?: string
  ): Promise<{
    eligibilityVerification: any;
    preClaimValidation: any;
    cmsComplianceCheck: any;
    automatedInsuranceValidation: any;
    clearinghouseIntegration: any;
    confidenceIndicators: any;
    humanReviewFlags: string[];
  }> {
    try {
      console.log('Starting Hyper-Intelligent Eligibility Processing with Availity Integration...');

      // Step 1: Extract insurance information from processed document data
      const insuranceInfo: InsuranceInfo = {
        primaryInsurance: extractedData.insuranceInfo?.primaryInsurance || 'Unknown',
        policyNumber: extractedData.insuranceInfo?.policyNumber || '',
        memberID: extractedData.insuranceInfo?.memberID || extractedData.insuranceInfo?.subscriberID || '',
        subscriberName: extractedData.patientName,
        relationshipToSubscriber: extractedData.insuranceInfo?.relationshipToSubscriber || 'self'
      };

      const patientInfo = {
        firstName: extractedData.patientName?.split(' ')[0] || 'Unknown',
        lastName: extractedData.patientName?.split(' ').slice(1).join(' ') || 'Unknown',
        dateOfBirth: extractedData.dateOfBirth,
        address: extractedData.contactInfo?.address
      };

      // Step 2: Real-time Availity Clearinghouse Verification
      let availityVerification = null;
      let clearinghouseErrors = [];
      
      try {
        console.log('Performing real-time Availity clearinghouse verification...');
        availityVerification = await this.availityService.verifyMemberEligibility(insuranceInfo, patientInfo);
        console.log('Availity verification completed successfully');
      } catch (error) {
        console.error('Availity verification failed:', error);
        clearinghouseErrors.push(`Availity verification failed: ${error.message}`);
        
        // Fallback to general eligibility service
        try {
          console.log('Falling back to general eligibility verification...');
          availityVerification = await this.eligibilityService.verifyInsuranceEligibility(insuranceInfo, patientInfo);
        } catch (fallbackError) {
          console.error('Fallback eligibility verification failed:', fallbackError);
          clearinghouseErrors.push(`Fallback verification failed: ${fallbackError.message}`);
        }
      }

      // Step 3: AI-Enhanced Pre-Claim Validation
      const preClaimValidation = await this.performPreClaimValidation(extractedData, availityVerification);

      // Step 4: CMS Compliance Validation
      const cmsComplianceCheck = await this.performCMSComplianceCheck(extractedData, availityVerification);

      // Step 5: Automated Insurance Data Validation
      const automatedInsuranceValidation = await this.validateInsuranceData(extractedData, availityVerification);

      // Step 6: Generate Confidence Indicators
      const confidenceIndicators = await this.generateConfidenceIndicators(
        extractedData,
        availityVerification,
        preClaimValidation,
        cmsComplianceCheck
      );

      // Step 7: Identify Human Review Flags
      const humanReviewFlags = this.identifyHumanReviewFlags(
        extractedData,
        availityVerification,
        clearinghouseErrors,
        confidenceIndicators
      );

      // Step 8: Clearinghouse Integration Summary
      const clearinghouseIntegration = {
        provider: 'Availity',
        environment: this.availityService.getConfiguration().currentEnvironment,
        apiConfiguration: this.availityService.getConfiguration(),
        verificationStatus: availityVerification ? 'success' : 'failed',
        errors: clearinghouseErrors,
        transactionId: availityVerification?.clearinghouseResponse?.transactionControlNumber,
        processingTime: new Date().toISOString(),
        securityCompliance: ['HIPAA_EXTERNAL'],
        backendSystem: 'TYK'
      };

      return {
        eligibilityVerification: availityVerification,
        preClaimValidation,
        cmsComplianceCheck,
        automatedInsuranceValidation,
        clearinghouseIntegration,
        confidenceIndicators,
        humanReviewFlags
      };

    } catch (error) {
      console.error('Hyper-Intelligent Eligibility Processing failed:', error);
      throw new Error(`Enhanced eligibility processing failed: ${error.message}`);
    }
  }

  /**
   * AI-Enhanced Pre-Claim Validation
   */
  private async performPreClaimValidation(extractedData: ExtractedReferralData, eligibilityResult: any): Promise<any> {
    try {
      const validationPrompt = `
You are a healthcare pre-claim validation AI specialist. Analyze the extracted patient data and eligibility verification results to identify potential claim issues before submission.

Extracted Data: ${JSON.stringify(extractedData)}
Eligibility Results: ${JSON.stringify(eligibilityResult)}

Perform comprehensive pre-claim validation focusing on:
1. Coverage validation for requested services
2. Authorization requirements
3. Billing compliance issues
4. Documentation completeness
5. Potential claim denial risks

Return JSON with detailed validation results and recommendations.`;

      const response = await this.anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        system: 'You are a healthcare pre-claim validation specialist. Provide detailed analysis in JSON format.',
        max_tokens: 2000,
        messages: [{ role: 'user', content: validationPrompt }]
      });

      return JSON.parse(response.content[0].text);
    } catch (error) {
      return { error: 'Pre-claim validation failed', details: error.message };
    }
  }

  /**
   * CMS Compliance Check
   */
  private async performCMSComplianceCheck(extractedData: ExtractedReferralData, eligibilityResult: any): Promise<any> {
    try {
      const compliancePrompt = `
You are a CMS compliance validation AI specialist. Analyze the patient data and eligibility results for CMS compliance requirements.

Patient Data: ${JSON.stringify(extractedData)}
Eligibility Results: ${JSON.stringify(eligibilityResult)}

Check compliance with:
1. CMS home health regulations
2. Medicare coverage requirements
3. Documentation standards
4. Billing compliance
5. Quality reporting requirements

Return JSON with compliance assessment and required actions.`;

      const response = await this.anthropic.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        system: 'You are a CMS compliance specialist. Provide detailed compliance analysis in JSON format.',
        max_tokens: 2000,
        messages: [{ role: 'user', content: compliancePrompt }]
      });

      return JSON.parse(response.content[0].text);
    } catch (error) {
      return { error: 'CMS compliance check failed', details: error.message };
    }
  }

  /**
   * Automated Insurance Data Validation
   */
  private async validateInsuranceData(extractedData: ExtractedReferralData, eligibilityResult: any): Promise<any> {
    const validation = {
      memberIdValidation: {
        extracted: extractedData.insuranceInfo?.memberID,
        verified: eligibilityResult?.clearinghouseResponse?.subscriber?.memberId,
        matches: extractedData.insuranceInfo?.memberID === eligibilityResult?.clearinghouseResponse?.subscriber?.memberId,
        confidence: 0
      },
      payerValidation: {
        extracted: extractedData.insuranceInfo?.primaryInsurance,
        verified: eligibilityResult?.planDetails?.payerName,
        matches: false,
        confidence: 0
      },
      planValidation: {
        extracted: extractedData.insuranceInfo?.planName,
        verified: eligibilityResult?.planDetails?.planName,
        matches: false,
        confidence: 0
      },
      overallValidation: {
        score: 0,
        status: 'pending',
        issues: []
      }
    };

    // Calculate validation scores
    validation.memberIdValidation.confidence = validation.memberIdValidation.matches ? 100 : 0;
    
    validation.payerValidation.matches = validation.payerValidation.extracted?.toLowerCase()?.includes(
      validation.payerValidation.verified?.toLowerCase() || ''
    ) || false;
    validation.payerValidation.confidence = validation.payerValidation.matches ? 85 : 20;

    validation.planValidation.matches = validation.planValidation.extracted?.toLowerCase()?.includes(
      validation.planValidation.verified?.toLowerCase() || ''
    ) || false;
    validation.planValidation.confidence = validation.planValidation.matches ? 90 : 30;

    validation.overallValidation.score = Math.round(
      (validation.memberIdValidation.confidence + validation.payerValidation.confidence + validation.planValidation.confidence) / 3
    );

    validation.overallValidation.status = validation.overallValidation.score >= 80 ? 'validated' : 
                                         validation.overallValidation.score >= 60 ? 'partial' : 'failed';

    if (!validation.memberIdValidation.matches) {
      validation.overallValidation.issues.push('Member ID mismatch detected');
    }
    if (!validation.payerValidation.matches) {
      validation.overallValidation.issues.push('Insurance payer mismatch detected');
    }
    if (!validation.planValidation.matches) {
      validation.overallValidation.issues.push('Insurance plan mismatch detected');
    }

    return validation;
  }

  /**
   * Generate Confidence Indicators
   */
  private async generateConfidenceIndicators(
    extractedData: ExtractedReferralData,
    eligibilityResult: any,
    preClaimValidation: any,
    cmsComplianceCheck: any
  ): Promise<any> {
    const indicators = {
      dataExtractionConfidence: extractedData.confidence || 0,
      eligibilityConfidence: eligibilityResult?.isEligible ? 95 : 30,
      preClaimValidationConfidence: preClaimValidation?.validationScore || 50,
      cmsComplianceConfidence: cmsComplianceCheck?.complianceScore || 50,
      overallConfidence: 0,
      riskLevel: 'medium',
      recommendedAction: 'review'
    };

    indicators.overallConfidence = Math.round(
      (indicators.dataExtractionConfidence + indicators.eligibilityConfidence + 
       indicators.preClaimValidationConfidence + indicators.cmsComplianceConfidence) / 4
    );

    if (indicators.overallConfidence >= 90) {
      indicators.riskLevel = 'low';
      indicators.recommendedAction = 'auto-approve';
    } else if (indicators.overallConfidence >= 70) {
      indicators.riskLevel = 'medium';
      indicators.recommendedAction = 'review';
    } else {
      indicators.riskLevel = 'high';
      indicators.recommendedAction = 'manual-review-required';
    }

    return indicators;
  }

  /**
   * Identify Human Review Flags
   */
  private identifyHumanReviewFlags(
    extractedData: ExtractedReferralData,
    eligibilityResult: any,
    clearinghouseErrors: string[],
    confidenceIndicators: any
  ): string[] {
    const flags: string[] = [];

    // Data extraction flags
    if (extractedData.confidence < 80) {
      flags.push('LOW_DATA_EXTRACTION_CONFIDENCE');
    }
    if (extractedData.missingFields?.length > 0) {
      flags.push('MISSING_REQUIRED_FIELDS');
    }
    if (extractedData.validationIssues?.length > 0) {
      flags.push('DATA_VALIDATION_ISSUES');
    }

    // Eligibility flags
    if (!eligibilityResult?.isEligible) {
      flags.push('ELIGIBILITY_DENIED');
    }
    if (eligibilityResult?.authorizationRequired) {
      flags.push('PRIOR_AUTHORIZATION_REQUIRED');
    }

    // Clearinghouse flags
    if (clearinghouseErrors.length > 0) {
      flags.push('CLEARINGHOUSE_VERIFICATION_FAILED');
    }

    // Confidence flags
    if (confidenceIndicators.overallConfidence < 70) {
      flags.push('LOW_OVERALL_CONFIDENCE');
    }
    if (confidenceIndicators.riskLevel === 'high') {
      flags.push('HIGH_RISK_ASSESSMENT');
    }

    // Compliance flags
    if (eligibilityResult?.complianceFlags?.length > 0) {
      flags.push('COMPLIANCE_ISSUES_DETECTED');
    }

    return flags;
  }
}

export const intakeAutomationService = new IntakeAutomationService();